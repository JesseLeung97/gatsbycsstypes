#! /usr/bin/env node
//#region Import
import path from "path";
import fs from "fs";
import readline from "readline";
import config from "../gctconfig";
import { lineBuilder, logger } from "./util";
//#endregion

//#region Utility
function getCssFiles(root: string) {
    let cssFilePaths: string[] = [];
    let currentDepth = 0;

    function checkDir(dirPath: string) {
        if(currentDepth > config.MAX_RECURSION_DEPTH) {
            logger.recursionDepthExceeded();
            return;
        }

        if(config.IGNORED_FOLDERS.indexOf(path.resolve(dirPath)) > -1) {
            return;
        }

        currentDepth++;
        if(fs.statSync(path.resolve(dirPath)).isFile()) {
            if(path.extname(dirPath) === config.TARGET_FILE_EXT) {
                cssFilePaths.push(dirPath);
            }
            return;
        };

        fs.readdirSync(path.resolve(dirPath)).forEach(dir => {
            checkDir(path.resolve(dirPath, dir));
        });
    }

    checkDir(root);

    return cssFilePaths;
}

async function buildDefinitionFiles(filePaths: string[]) {
    let generatedFiles: Record<string, string> = {};
    
    async function buildFile(filePath: string) { 
        let cssClassNames: string[] = []; 
        const fileStream = fs.createReadStream(filePath);
        const rl = readline.createInterface({
            input: fileStream,
            crlfDelay: Infinity
        });

        for await (const line of rl) {
            const cleanedClassNames = getCssClassName(line);
            if(cleanedClassNames.length > 0) {
                cssClassNames = [...cssClassNames, ...cleanedClassNames];
            }
        }

        cssClassNames = [...new Set(cssClassNames)];

        writeCssDefineFile(cssClassNames, filePath);
    }
    
    function getCssClassName(line: string) {
        let cleanedClassNames: string[] = [];

        line = line.replace(/\s/g, "");

        const fragments = line.split('.').filter(Boolean);
        fragments.forEach((frag) => {
            let regexMatches = frag.match(new RegExp(config.TARGET_REGEX));
            if(regexMatches === null) {
                return;
            };

            cleanedClassNames.push(...regexMatches);
        });

        return cleanedClassNames;
    }

    function writeCssDefineFile(classNames: string[], filePath: string) {
        let fileBuilder = "";
        fileBuilder += lineBuilder(["// This file is autogenerated."]);
        fileBuilder += lineBuilder(["declare module \"*.module.css\" {"]);
        classNames.forEach(className => {
            fileBuilder += lineBuilder([`const ${className}`, ": string;"], 1);
        });
        fileBuilder += lineBuilder([]);
        fileBuilder += lineBuilder(["export {"], 1);
        classNames.forEach(className => {
            fileBuilder += lineBuilder([`${className},`], 2);
        });
        fileBuilder += lineBuilder(["}"], 1);
        fileBuilder += lineBuilder(["}"]); 
        
        const parentDir = path.resolve(path.dirname(filePath));
        const newFilePath = path.resolve(parentDir, "styles.d.ts");
        
        generatedFiles[filePath] = newFilePath;

        fs.writeFile(newFilePath, fileBuilder, (err) => {
            if(err !== null) {
                logger.generalError(err);
            }
        });
    }

    function writeToDefineFile(fileRecord: Record<string, string>) {
        let fileBuilder = "";
        fileBuilder += lineBuilder(["// This file is autogenerated."]);
        fileBuilder += lineBuilder([`"use strict"; `, `Object.defineProperty(exports, "__esModule", { value: true });`]);
        fileBuilder += lineBuilder(["const generatedFiles = {"]);
        Object.keys(fileRecord).forEach(cssFilePath => {
            const generatedDefinitionFilePath = generatedFiles[cssFilePath];
            fileBuilder += lineBuilder([`"${cssFilePath}": "${generatedDefinitionFilePath}",`], 1);
        });
        fileBuilder += lineBuilder(["}"]);
        fileBuilder += lineBuilder([]);
        fileBuilder += lineBuilder(["exports.default = generatedFiles;"]);

        const recordFilePath = path.resolve(__dirname, "..", "gctrecord.js");

        fs.writeFile(recordFilePath, fileBuilder, (err) => {
            if(err !== null) {
                logger.generalError(err);
            }
        });
    }

    Promise.all(filePaths.map(path => buildFile(path))).then(_ => {
        writeToDefineFile(generatedFiles);
    });    
}
//#endregion

//#region Execution
function main() {
    logger.startGeneratingFiles();

    if(!config.IS_INITIALIZED) {
        logger.notInitialized();
        return;
    }
    
    const cssFiles: string[] = getCssFiles(config.APP_ROOT);

    buildDefinitionFiles(cssFiles); 

    logger.finishGeneratingFiles();
}

main();
//#endregion

