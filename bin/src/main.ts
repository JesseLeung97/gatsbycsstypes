#! /usr/bin/env node
//#region Import
import path from "path";
import fs from "fs";
import readline, { ReadLine } from "readline";
import config from "../gctconfig";
import { lineBuilder, logger } from "./util";
import generatedFiles from "../gctrecord";
//#endregion

//#region Utility
function getCssFiles(root: string) {
    let cssFilePaths: string[] = [];
    const startDepth = 0;

    function checkDir(dirPath: string, currDepth: number) {
        if(currDepth > config.MAX_RECURSION_DEPTH) {
            logger.recursionDepthExceeded();
            return;
        }

        if(config.IGNORED_FOLDERS.indexOf(path.resolve(dirPath)) > -1) {
            return;
        }

        if(fs.statSync(path.resolve(dirPath)).isFile()) {
            if(path.extname(dirPath) === config.TARGET_FILE_EXT) {
                cssFilePaths.push(dirPath);
            }
            return;
        };

        fs.readdirSync(path.resolve(dirPath)).forEach(dir => {
            checkDir(path.resolve(dirPath, dir), currDepth + 1);
        });
    }

    checkDir(root, startDepth);

    return cssFilePaths;
}

async function buildDefinitionFiles(filePaths: string[]) {
    async function buildFile(filePath: string) { 
        let cssClassNames: string[] = []; 
        const fileStream = fs.createReadStream(filePath);
        const rl = readline.createInterface({
            input: fileStream,
            crlfDelay: Infinity
        });

        let fileContents = "";
        for await (const line of rl) {
            fileContents += line;
        }

        cssClassNames = [...parseCssClassNames(fileContents)];
        writeCssDefineFile(cssClassNames, filePath);
    }

    function parseCssClassNames(fileContents: string) {
        const classContentRegExp = new RegExp(/\{(.*?)\}/g);
        const mediaQueryRegExp = new RegExp(/@media[^{]+\{([\s\S]+?})\s*}/g);
        const keyframesRegExp = new RegExp(/@keyframes[^{]+\{([\s\S]+?})\s*}/g);
        const mediaQueryNameStartRegExp = new RegExp(/@media[^{]+\{/);

        let mediaQueries = fileContents.match(mediaQueryRegExp);
        fileContents = fileContents.replace(mediaQueryRegExp, "");

        function parseMediaQueryClassNames(matches: RegExpMatchArray | null) {
            if(matches === null) {
                return "";
            }
            const initialClassNames = "";
            const classNames = matches.reduce(
                (previousValue, currentValue) => previousValue + currentValue.substring(0, currentValue.length -1).replace(mediaQueryNameStartRegExp, ""),
                initialClassNames
            );
            return classNames;
        }
        
        const mediaClasses = parseMediaQueryClassNames(mediaQueries);
        const classes = fileContents
            .replace(mediaQueryRegExp, "")
            .concat(mediaClasses)
            .replace(keyframesRegExp, "")
            .replace(classContentRegExp, "")
            .split('.')
            .filter(Boolean)
            .filter(elem => elem.indexOf('-') < 0)
            .map((elem) => elem.replace(/\s/g, "").replace(/\,/g, "").split(':')[0])
            .filter(Boolean);
        return new Set(classes);
    }

    function writeCssDefineFile(classNames: string[], filePath: string) {
        let fileBuilder = "";
        fileBuilder += lineBuilder(["// This file is autogenerated."]);
        fileBuilder += lineBuilder(["declare module \"*.module.css\" {"]);
        classNames.forEach(className => {
            fileBuilder += lineBuilder([`const ${className}`, ": string;"], 1);
        });
        fileBuilder += lineBuilder([]);
        fileBuilder += lineBuilder(["export {"], 1);
        classNames.forEach(className => {
            fileBuilder += lineBuilder([`${className},`], 2);
        });
        fileBuilder += lineBuilder(["}"], 1);
        fileBuilder += lineBuilder(["}"]); 
        
        const parentDir = path.resolve(path.dirname(filePath));
        const newFilePath = path.resolve(parentDir, "styles.d.ts");
        

        fs.writeFile(newFilePath, fileBuilder, (err) => {
            if(err !== null) {
                logger.generalError(err);
            }
        });
    }

    Promise.all(filePaths.map(path => buildFile(path)));
}

function writeToDefineFile(filePaths: string[]) {
    let fileRecord: Record<string, string> = {};
   
    filePaths.forEach(path => {
        const lastEditedTime = fs.statSync(path).mtimeMs.toString();
        fileRecord[path] = lastEditedTime;
    });

    let fileBuilder = "";
    fileBuilder += lineBuilder(["// This file is autogenerated."]);
    fileBuilder += lineBuilder([`"use strict"; `, `Object.defineProperty(exports, "__esModule", { value: true });`]);
    fileBuilder += lineBuilder(["const generatedFiles = {"]);
    Object.keys(fileRecord).forEach(cssFilePath => {
        const lastModifiedTime = fileRecord[cssFilePath];
        fileBuilder += lineBuilder([`"${cssFilePath}": "${lastModifiedTime}",`], 1);
    });
    fileBuilder += lineBuilder(["}"]);
    fileBuilder += lineBuilder([]);
    fileBuilder += lineBuilder(["exports.default = generatedFiles;"]);

    const recordFilePath = path.resolve(__dirname, "..", "gctrecord.js");

    fs.writeFile(recordFilePath, fileBuilder, (err) => {
        if(err !== null) {
            logger.generalError(err);
        }
    });
}

export {
    getCssFiles,
    buildDefinitionFiles,
    writeToDefineFile
}
//#endregion

//#region Execution
function main() {
    logger.startGeneratingFiles();

    if(!config.IS_INITIALIZED) {
        logger.notInitialized();
        return;
    }
    
    const cssFiles: string[] = getCssFiles(config.APP_ROOT);

    buildDefinitionFiles(cssFiles); 

    writeToDefineFile(cssFiles);

    logger.finishGeneratingFiles();
}

main();
//#endregion

